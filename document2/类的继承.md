# 继承
• 子类继承了父类的方法和属性
• 使用子类的引用可以调用父类的共有方法
• 使用子类的引用可以访问父类的共有属性
• 就好像子类的引用可以一物二用，既可以当作父类的引用使用，又可以当作子类的引用 使用。

子类不能访问父类的private成员（包括方法和属性）；


1、子类拥有父类非private的属性和方法。
2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3、子类可以用自己的方式实现父类的方法。
4、对于构造器而言，它只能够被调用，而不能被继承。调用父类的构造方法我们使用super()即可。（默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。）


# 子类覆盖（override）父类的方法 这才是继承的终极奥义 否则可以考虑组合
子类写一个和父类方法签名、返回值一致的方法

# 多态，覆盖。同一个方法不同的行为


# 子类父类沟通的桥梁 super()
1、super是子类和父类交流的桥梁，但是并不是父类的引用;
使用super可以调用父类的public属性;
super.buy() // public 属性

2、调用父类的构造方法
super(参数)

### 回忆一下
## 之前的构造方法重载，this()要在第一行调用后，super调用父类的构造方法也要在第一行，这是不允许的。我们可以写一个init函数，实现


{
    封装、继承、多态
}


# 类里的静态方法也是可以被继承的
方法签名和父类一样，返回值也要和父类一模一样

不推荐用引用调用静态方法（用引用的类型 调相关的方法），要用类去调用静态方法